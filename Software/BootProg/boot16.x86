;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                          ;;
;;         "BootProg" Loader v 1.5 by Alexey Frunze (c) 2000-2015           ;;
;;                           2-clause BSD license.                          ;;
;;                                                                          ;;
;;                                                                          ;;
;;                              How to Compile:                             ;;
;;                              ~~~~~~~~~~~~~~~                             ;;
;; nasm boot16.asm -f bin -o boot16.bin                                     ;;
;;                                                                          ;;
;;                                                                          ;;
;;                                 Features:                                ;;
;;                                 ~~~~~~~~~                                ;;
;; - FAT16 supported                                                        ;;
;;                                                                          ;;
;; - Loads a 16-bit executable file in the MS-DOS .COM or .EXE format       ;;
;;   from the root directory of a disk and transfers control to it          ;;
;;   (the "ProgramName" variable holds the name of the file to be loaded)   ;;
;;                                                                          ;;
;; - Prints an error if the file isn't found or couldn't be read            ;;
;;   (the "RE" message stands for "Read Error",                             ;;
;;    the "NF" message stands for "file Not Found")                         ;;
;;   and waits for a key to be pressed, then executes the Int 19h           ;;
;;   instruction and lets the BIOS continue bootstrap.                      ;;
;;                                                                          ;;
;;                                                                          ;;
;;                             Known Limitations:                           ;;
;;                             ~~~~~~~~~~~~~~~~~~                           ;;
;; - Works only on the 1st MBR partition which must be a PRI DOS partition  ;;
;;   with FAT16 (File System ID: 4, 6)                                      ;;
;;                                                                          ;;
;;                                                                          ;;
;;                                Known Bugs:                               ;;
;;                                ~~~~~~~~~~~                               ;;
;; - All bugs are fixed as far as I know. The boot sector has been tested   ;;
;;   on my HDD.                                                             ;;
;;                                                                          ;;
;;                                                                          ;;
;;                               Memory Layout:                             ;;
;;                               ~~~~~~~~~~~~~~                             ;;
;; The diagram below shows the typical memory layout. The actual location   ;;
;; of the boot sector and its stack may be lower than A0000H if the BIOS    ;;
;; reserves memory for its Extended BIOS Data Area just below A0000H and    ;;
;; reports less than 640 KB of RAM via its Int 12H function.                ;;
;;                                                                          ;;
;;                                            physical address              ;;
;;                 +------------------------+ 00000H                        ;;
;;                 | Interrupt Vector Table |                               ;;
;;                 +------------------------+ 00400H                        ;;
;;                 |     BIOS Data Area     |                               ;;
;;                 +------------------------+ 00500H                        ;;
;;                 | PrtScr Status / Unused |                               ;;
;;                 +------------------------+ 00600H                        ;;
;;                 |      Loaded Image      |                               ;;
;;                 +------------------------+ nnnnnH                        ;;
;;                 |    Available Memory    |                               ;;
;;                 +------------------------+ A0000H - 512 - 2KB            ;;
;;                 |     2KB Boot Stack     |                               ;;
;;                 +------------------------+ A0000H - 512                  ;;
;;                 |       Boot Sector      |                               ;;
;;                 +------------------------+ A0000H                        ;;
;;                 |        Video RAM       |                               ;;
;;                                                                          ;;
;;                                                                          ;;
;;                   Boot Image Startup (register values):                  ;;
;;                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                  ;;
;;  dl = BIOS boot drive number (e.g. 0, 80H)                               ;;
;;  cs:ip = program entry point                                             ;;
;;  ss:sp = program stack (don't confuse with boot sector's stack)          ;;
;;  COM program defaults: cs = ds = es = ss = 50h, sp = 0, ip = 100h        ;;
;;  EXE program defaults: ds = es = 50h, other stuff depends on EXE header  ;;
;;  Magic numbers:                                                          ;;
;;    si = 16381 (prime number 2**14-3)                                     ;;
;;    di = 32749 (prime number 2**15-19)                                    ;;
;;    bp = 65521 (prime number 2**16-15)                                    ;;
;;  The magic numbers let the program know whether it has been loaded by    ;;
;;  this boot sector or by MS-DOS, which may be handy for universal, bare-  ;;
;;  metal and MS-DOS programs.                                              ;;
;;                                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[BITS 16]

?                       equ     0
ImageLoadSeg            equ     60h     ; <=07Fh because of "push byte ImageLoadSeg" instructions

[SECTION .text]
[ORG 0]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Boot sector starts here ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        jmp     short   start                   ; MS-DOS/Windows checks for this jump
        nop
bsOemName               DB      "BootProg"      ; 0x03

;;;;;;;;;;;;;;;;;;;;;
;; BPB starts here ;;
;;;;;;;;;;;;;;;;;;;;;

bpbBytesPerSector       DW      ?               ; 0x0B
bpbSectorsPerCluster    DB      ?               ; 0x0D
bpbReservedSectors      DW      ?               ; 0x0E
bpbNumberOfFATs         DB      ?               ; 0x10
bpbRootEntries          DW      ?               ; 0x11
bpbTotalSectors         DW      ?               ; 0x13
bpbMedia                DB      ?               ; 0x15
bpbSectorsPerFAT        DW      ?               ; 0x16
bpbSectorsPerTrack      DW      ?               ; 0x18
bpbHeadsPerCylinder     DW      ?               ; 0x1A
bpbHiddenSectors        DD      ?               ; 0x1C
bpbTotalSectorsBig      DD      ?               ; 0x20

;;;;;;;;;;;;;;;;;;;
;; BPB ends here ;;
;;;;;;;;;;;;;;;;;;;

bsDriveNumber           DB      ?               ; 0x24
bsUnused                DB      ?               ; 0x25
bsExtBootSignature      DB      ?               ; 0x26
bsSerialNumber          DD      ?               ; 0x27
bsVolumeLabel           DB      "NO NAME    "   ; 0x2B
bsFileSystem            DB      "FAT16   "      ; 0x36

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Boot sector code starts here ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

start:
        cld                     ; clear direction flag

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; How much RAM is there? ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        int     12h             ; get conventional memory size (in KBs)
                                ; BIOS interrupt 12h returns contiguous memory
                                ; starting at $0000 as kilobytes in register AX
        shl     ax, 6           ; and convert it to 16-byte paragraphs
                                ; by shifting left by 6 (multiply by 64)
                                ; ... why 16 byte paragraphs???

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reserve memory for the boot sector and its stack ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        sub     ax, 512 / 16    ; reserve 512 bytes for the boot sector code
                                ; by subtracting 32 from AX
        mov     es, ax          ; es:0 -> top - 512
                                ; copy AX into ES (Extra Segment Register)

        sub     ax, 2048 / 16   ; reserve 2048 bytes for the stack
                                ; by subtracting 128 from AX
        mov     ss, ax          ; ss:0 -> top - 512 - 2048
                                ; copy AX into the Stack Segment Register
        mov     sp, 2048        ; 2048 bytes for the stack
                                ; copy 2048 into the Stack Pointer Register

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copy ourselves to top of memory ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; this copies the entire 512 byte boot sector from the disk, including FAT 
; headers, to the top of conventional memory

        mov     cx, 256         ; use CX as the loop counter (256 words to copy)
        mov     si, 7C00h       ; Source Index register set to $7C00
                                ; (I think this may be a BIOS thing -- where the boot
                                ; block gets copied to RAM initially?)
        xor     di, di          ; clear Destination Index register
        mov     ds, di          ; also clear Data Segment register
        rep     movsw           ; repeat string operation:
                                ; fetches word from address at SI,
                                ; stores it at address in DI,
                                ; increments SI & DI by 2
                                ; repeats until CX==0

;;;;;;;;;;;;;;;;;;;;;;
;; Jump to the copy ;;
;;;;;;;;;;;;;;;;;;;;;;

        push    es              ; push ES to the stack
                                ; ES currently holds the top of RAM, minus the
                                ; 512 bytes we made room for earlier
        push    byte main       ; push the address of function 'main' to stack
        retf                    ; return far: jump to address on the stack ('main')

main:
        push    cs              ; push Code Segment register to stack
        pop     ds              ; copy Code Segment register to Data Segment register

        mov     [bsDriveNumber], dl     ; store BIOS boot drive number

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reserve memory for the FAT16 image (128KB max) ;;
;; and load it in its entirety                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; this first bit calculates how much room we need to make on the stack to load
; the FAT into memory. It appears to be creating a stack frame, using the ES 
; register similarly to how the M68k LINK uses A6 to make a stack frame and 
; store temporary variables there

; divide BytesPerSector by 16 to get the number of Paragraphs of memory we need
; then subtract that value from the stack segment register & copy to the
; extra segment register, so that we can use ES as a stack frame segment
; clear BX to point to the bottom of this new stack frame
        mov     ax, [bpbBytesPerSector] ; fetch the Bytes Per Sector value from
                                        ; the FAT header in memory
        shr     ax, 4                   ; ax = sector size in (16B) paragraphs 
                                        ; shift right by 4 (divide by 16)
        mov     cx, [bpbSectorsPerFAT]  ; cx = FAT size in sectors
        mul     cx                      ; ax = FAT size in paragraphs
                                        ; DX:AX <= AX * CX

        mov     di, ss                  ; copy Stack Segment register to
                                        ; Destination Index register
        sub     di, ax                  ; DI <= DI - AX
        mov     es, di                  ; copy DI to the Extra Segment register
        xor     bx, bx                  ; es:bx -> buffer for the FAT
                                        ; .. doesn't this just clear BX?

; Add the 32-bit HiddenSectors value to the 16-bit Reserved Sectors value
; The BX register is 0, so we can use the carry flag from the first ADD instruction
; with the ADC (Add w/Carry) instruction to ensure proper 32-bit arithmetic
; from differently-sized variables.
; At the end of this operation the register pair DX:AX holds the sum
; of the HiddenSectors and ReservedSectors parameters
        mov     ax, [bpbHiddenSectors]      ; AX = first word of the number of hidden sectors
        mov     dx, [bpbHiddenSectors+2]    ; DX = second word of the number of hidden sectors
        add     ax, [bpbReservedSectors]    ; add number of reserved sectors to low word
                                            ; of the hidden sectors count
        adc     dx, bx                  ; dx:ax = LBA
                                        ; after that XOR instruction, BX=0, but ADC
                                        ; will use the carry flag from the previous
                                        ; ADD instruction just in case it is set


        call    ReadSector              ; read the sector into the stack frame
                                        ; this function takes these parameters:
                                        ;   DX:AX   = sector LBA
                                        ;   CX      = count of sectors to copy
                                        ;   ES:BX   = read buffer address
                                        ; returns 1 in CF for errors
                                        ;
                                        ; ... good god I hate segmented addressing   

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reserve memory for the root directory  ;;
;; and load it in its entirety (16KB max) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; The last function (ReadSector) used DX:AX for the LBA of the starting sector
; to read. This first bit here just copies DX:AX into DI:BX
        mov     bx, ax
        mov     di, dx                  ; save LBA to di:bx

; Root Directory table entries are 32 bytes long. Get the total number of
; Root Directory entries and multiply it by 32 to get the total number of bytes
; used for the complete Root Directory table. Divide this by the number of
; bytes per sector to get a count of the total number of sectors we needed
; to fetch the entire root directory
        mov     ax, 32
        mov     si, [bpbRootEntries]
        mul     si
        div     word [bpbBytesPerSector]
        mov     cx, ax                  ; cx = root directory size in sectors

; Get the count of FATS (usually 2) and multiply it by the total number of 
; sectors consumed by a single copy of the FAT. Add this sector count to the
; LBA we just used.
        mov     al, [bpbNumberOfFATs]
        cbw                             ; convert byte to word 
                                        ; (sign-extend AL to AX)
        mul     word [bpbSectorsPerFAT]
        add     ax, bx
        adc     dx, di                  ; dx:ax = LBA

; Save the segment register we used earlier for reading FAT sectors
        push    es                      ; push FAT segment (2nd parameter)

; This is loading a constant value into the Extra Segment register.
; I think this is setting up the segment & address that will be used to load
; the executable into memory. Clearing BX so that the buffer pointer will
; point to the bottom of the segment. We're not yet to the point of actually
; loading the executable into memory though, so we're going to borrow that 
; memory buffer for saving the root directory so that we can find the file.
        push    byte ImageLoadSeg
        pop     es
        xor     bx, bx                  ; es:bx -> buffer for root directory

; So this should be reading the root directory into that constant memory 
; segment that was just set up.
        call    ReadSector

        add     ax, cx
        adc     dx, bx                  ; adjust LBA for cluster data

        push    dx
        push    ax                      ; push LBA for data (1st parameter)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Look for the COM/EXE file to load and run ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     di, bx                  ; es:di -> root entries array
        mov     dx, si                  ; dx = number of root entries
        mov     si, ProgramName         ; ds:si -> program name

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Looks for a file/dir by its name      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input:  DS:SI -> file name (11 chars) ;;
;;         ES:DI -> root directory array ;;
;;         DX = number of root entries   ;;
;; Output: SI = cluster number           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FindName:
        mov     cx, 11
FindNameCycle:
        cmp     byte [es:di], ch        ; since we just loaded CX with 11,
                                        ; CH=$00 & CL=$0B
                                        ; so this is comparing the first byte
                                        ; of this root directory entry
                                        ; with 0 to check if we've reached
                                        ; the end of the list
        je      FindNameFailed          ; end of root directory
        pusha                           ; save all registers to stack
        repe    cmpsb                   ; repeat if equal:
                                        ; compare strings byte-for-byte
                                        ; increment SI & DI
        popa                            ; restore all registers
        je      FindNameFound
        add     di, 32                  ; increment destination index by 32
                                        ; to point to next entry in the root
                                        ; directory table
        dec     dx                      ; decrement counter of root directory
                                        ; entries that was provided to this 
                                        ; function
        jnz     FindNameCycle           ; next root entry
FindNameFailed:
        jmp     ErrFind
FindNameFound:
; offset $1A into a root directory entry is the low 16 bits of the entry's
; first cluster number, used to find the first cluster for this entry.
        mov     si, [es:di+1Ah]         ; si = cluster no.

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load the entire file ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

ReadNextCluster:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reads a FAT16 cluster      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Inout:  ES:BX -> buffer    ;;
;;         SI = cluster no    ;;
;; Output: SI = next cluster  ;;
;;         ES:BX -> next addr ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReadCluster:
; copy the stack pointer to the stack base pointer. Why? I'm not sure ...
        mov     bp, sp

; start by getting the address of the first cluster. There's a thing in FAT
; where the clusters are offset by 2, so that is accounted for when loading
; the cluster number into AX
; This is then multiplied by the number of sectors per cluster to get a sector
; address then this is added to the last LBA address we used 
; (pushed to stack previously)
        lea     ax, [si-2]
        xor     ch, ch                  ; clear high byte of CX
        mov     cl, [bpbSectorsPerCluster]
        mul     cx                      ; CX is the count of sectors to load
                                        ; (used by the ReadSector function)
                                        ; AX is an LBA offset which then gets
        add     ax, [bp]                ; added to the previous LBA used
        adc     dx, [bp+1*2]            ; (pushed to stack a while back)
                ; dx:ax = LBA

        call    ReadSector

; I'm struggling to figure out what's happening here, because it's dealing
; with some of the obnoxious x86 segment & index registers, etc.

; ES:BX is the memory pointer of the buffer where we just saved the cluster
; data read from the disk. The first thing we're doing here is updating the
; ES segment register with the number of paragraphs read for this sector
        mov     ax, [bpbBytesPerSector]
        shr     ax, 4                   ; ax = paragraphs per sector
        mul     cx                      ; ax = paragraphs read

        mov     cx, es                  ; get the existing segment value
        add     cx, ax                  ; and add the paragraphs read to it
        mov     es, cx                  ; es:bx updated
                                        ; and save the new segment

; now we need to traverse the FAT to find the next cluster we need to read
        add     si, si                  ; si = cluster * 2

        push    ds                      ; save data segment register

        ; this is loading "2nd parameter" into AX -- 2nd parameter was ES,
        ; the segment pointer where the FAT data was loaded into a stack frame
        mov     ax, [bp+2*2]            ; ds = FAT segment

        ; jump if Carry flag is not set (by the 'add si,si' instruction)
        jnc     First64
        add     ax, 1000h               ; adjust segemnt for 2nd part of FAT16
First64:
        mov     ds, ax
        mov     si, [si]                ; si = next cluster
        pop     ds                      ; restore data segment register

ReadClusterDone:

        cmp     si, 0FFF8h
        jc      ReadNextCluster         ; if not End Of File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Type detection, .COM or .EXE? ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        push    byte ImageLoadSeg
        pop     ds
        mov     ax, ds                  ; ax=ds=seg the file is loaded to

        cmp     word [0], 5A4Dh         ; "MZ" signature?

        je      RelocateEXE             ; yes, it's an EXE program

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Setup and run a .COM program ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        sub     ax, 10h                 ; "org 100h" stuff :)
        mov     es, ax
        mov     ds, ax
        mov     ss, ax
        xor     sp, sp
        push    es
        push    word 100h
        jmp     short Run

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Relocate, setup and run a .EXE program ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RelocateEXE:

        add     ax, [08h]               ; ax = image base
        mov     cx, [06h]               ; cx = reloc items
        mov     bx, [18h]               ; bx = reloc table pointer

        jcxz    RelocationDone

ReloCycle:
        mov     di, [bx]                ; di = item ofs
        mov     dx, [bx+2]              ; dx = item seg (rel)
        add     dx, ax                  ; dx = item seg (abs)

        push    ds
        mov     ds, dx                  ; ds = dx
        add     [di], ax                ; fixup
        pop     ds

        add     bx, 4                   ; point to next entry
        loop    ReloCycle

RelocationDone:

        mov     bx, ax
        add     bx, [0Eh]
        mov     ss, bx                  ; ss for EXE
        mov     sp, [10h]               ; sp for EXE

        add     ax, [16h]               ; cs
        push    ax
        push    word [14h]              ; ip
Run:
        mov     dl, [cs:bsDriveNumber]  ; pass the BIOS boot drive

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set the magic numbers so the program knows that it   ;;
;; has been loaded by this bootsector and not by MS-DOS ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     si, 16381 ; prime number 2**14-3
        mov     di, 32749 ; prime number 2**15-19
        mov     bp, 65521 ; prime number 2**16-15

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; All done, transfer control to the program now ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        retf

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Reads a sector using BIOS Int 13h fn 2 ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input:  DX:AX = LBA                    ;;
;;         CX    = sector count           ;;
;;         ES:BX -> buffer address        ;;
;; Output: CF = 1 if error                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ReadSector:
        pusha                           ; save all general-purpose registers
                                        ; to the stack (callee saves)

ReadSectorNext:
        mov     di, 5                   ; attempts to read

ReadSectorRetry:
        pusha                           ; save all registers to stack again

        div     word [bpbSectorsPerTrack]
                ; ax = LBA / SPT
                ; dx = LBA % SPT         = sector - 1
                                        ; the "word" keyword here tells the
                                        ; assembler to use DX:AX as dividend
                                        ; The divisor is the Sectors Per Track
                                        ; value loaded from the FAT header
                                        ;
                                        ; quotient is stored in AX
                                        ; remainder is stored in DX
                                        ; (which is what the comment is telling
                                        ; us here)

        mov     cx, dx                  ; CX now has the remainder
        inc     cx                      ; and increment it by 1
                ; cx = sector no.

        xor     dx, dx                  ; clear out dx?
        div     word [bpbHeadsPerCylinder]
                ; ax = (LBA / SPT) / HPC = cylinder
                ; dx = (LBA / SPT) % HPC = head

        mov     ch, al
                ; ch = LSB 0...7 of cylinder no.
        shl     ah, 6
        or      cl, ah
                ; cl = MSB 8...9 of cylinder no. + sector no.

        mov     dh, dl
                ; dh = head no.

        mov     dl, [bsDriveNumber]
                ; dl = drive no.

        mov     ax, 201h
                                        ; al = sector count = 1
                                        ; ah = 2 = read function no.

        int     13h                     ; read sectors
        jnc     ReadSectorDone          ; CF = 0 if no error

        xor     ah, ah                  ; ah = 0 = reset function
        int     13h                     ; reset drive

        popa
        dec     di
        jnz     ReadSectorRetry         ; extra attempt
        jmp     short ErrRead

ReadSectorDone:
        popa
        dec     cx
        jz      ReadSectorDone2         ; last sector

        add     bx, [bpbBytesPerSector] ; adjust offset for next sector
        add     ax, 1
        adc     dx, 0                   ; adjust LBA for next sector
        jmp     short ReadSectorNext

ReadSectorDone2:
        popa
        ret

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Error Messaging Code ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

ErrRead:
        mov     si, MsgErrRead
        jmp     short Error
ErrFind:
        mov     si, MsgErrFind
Error:
        mov     ah, 0Eh
        mov     bx, 7

        lodsb
        int     10h                     ; 1st char
        lodsb
        int     10h                     ; 2nd char

        xor     ah, ah
        int     16h                     ; wait for a key...
        mov     dl, [bsDriveNumber]     ; restore BIOS boot drive number
        int     19h                     ; bootstrap

;;;;;;;;;;;;;;;;;;;;;;
;; String constants ;;
;;;;;;;;;;;;;;;;;;;;;;

MsgErrRead      db      "RE"
MsgErrFind      db      "NF"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill free space with zeroes ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                times (512-13-($-$$)) db 0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Name of the file to load and run ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ProgramName     db      "STARTUP BIN"   ; name and extension each must be
                                        ; padded with spaces (11 bytes total)

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; End of the sector ID ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

                dw      0AA55h          ; BIOS checks for this ID